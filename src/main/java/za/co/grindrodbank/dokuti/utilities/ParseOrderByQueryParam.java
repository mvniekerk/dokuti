/****************************************************
* Copyright (c) 2019, Grindrod Bank Limited
* License MIT: https://opensource.org/licenses/MIT
****************************************************/
package za.co.grindrodbank.dokuti.utilities;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import org.springframework.util.StringUtils;

/**
 * Based on Spring's SortHandlerMethodArgumentResolver as we are unable to use the standard functionality for Pageable provided by Spring. <br/>
 * Because our controller interface classes are being generated by the swagger codegen... there is currently not way of getting Pageable via this method.
 */
public class ParseOrderByQueryParam {

    private static final String DEFAULT_PROPERTY_DELIMITER = ",";

    private ParseOrderByQueryParam() {
        throw new IllegalStateException("Utility class");
    }

    public static Sort resolveArgument(List<String> orderBy, String defaultSortField) {
        
        Sort defaultSort = Sort.by(Arrays.asList(new Order(Direction.ASC, defaultSortField)));

        // work around for odd codegen issue, not allowing arrays to be null
        orderBy = (orderBy != null && orderBy.get(0).contains("new ArrayList<>()")) ? null : orderBy;

        String[] source = orderBy != null ? orderBy.toArray(new String[0]) : null;
        // No orderBy parameter || Single empty parameter, e.g "orderBy="
        if ((source == null) || (source.length == 1 && !StringUtils.hasText(source[0]))) {
            return defaultSort;
        }

        return parseIntoSort(source);
    }

    private static Sort parseIntoSort(String[] source) {
        List<Order> allOrders = new ArrayList<>();

        boolean onlyOneOrderBy = false;
        // Spring already ...
        for (int i = 0; i < source.length; i++) {
            onlyOneOrderBy = !source[i].contains(DEFAULT_PROPERTY_DELIMITER);
        }

        if (onlyOneOrderBy) { // only 1 orderBy field has been used eg: ?orderBy=tag,desc
            String property = source[0];
            Direction direction = Direction.fromString(source[1]);
            allOrders.add(new Order(direction, property));
            return allOrders.isEmpty() ? null : Sort.by(allOrders);
        }

        for (String part : source) {
            if (part == null) {
                continue;
            }

            String[] elements = part.split(DEFAULT_PROPERTY_DELIMITER);
            Direction direction = elements.length == 0 ? null : Direction.fromString(elements[elements.length - 1]);

            for (int i = 0; i < elements.length; i++) {
                if (i == elements.length - 1 && direction != null) {
                    continue;
                }

                String property = elements[i];

                if (!StringUtils.hasText(property)) {
                    continue;
                }

                allOrders.add(new Order(direction, property));
            }
        }

        return allOrders.isEmpty() ? null : Sort.by(allOrders);

    }
}
